這幾天開始做aes
1.js是用utf-16編碼，可以用str.charCodeAt(x)去把x位置的unicode找出來
  這時候的unicode還要用toString轉換成16進位的字串，因為他是十進位的
2.字串的slice(x)是指你要第x位的字串，從頭開始算，如果是負的就從尾巴
3.parseInt(x,16)可以把身為字串的x以從16進位的轉成10進位，String.fromCharCode()
是String的涵式方法，功能是把身為數字的unicode轉換成字串
4.str.substr(x,n)不知為什麼str的s沒有大寫，命名和其他有點不同，這裡的x和n代表的各是
字串的起使點和要取的位數

5.開始做subByte，這裡單純的初始了一個同大小的陣列，依照每個原陣列的值從s_box找到相對
應的替換值，方使是把值從十六進位轉換到十進位當坐陣列的索引值，照著表和陣列之間的規律
性，找到對應的，這裡因為若是0開頭的的十六進位，例如0x08，會只剩下8。因此前面加上'0'後
，以slice(-2)確保能有兩位，也就是1byte為基本單位

6.做shiftRow，同樣的初始一個陣列，接個把剛剛subByte的結果，
以shiftArr[i][j] = subArr[i][((j%4)*4+j)%16]進行判斷後填入，這裡前面的(j%4)*4+j是因為
陣列索引值j等於0.4.8.12時不用移位，1.5.9.13g時往左移1位，2.6.10.14時則是兩位，依此類
推，可知j和4取餘數*4便是移位後的索引數字，而後面的%16則是避免超過陣列的情況發生，
例如13+4=17，但其實是要移到1，因此和16取餘數辨識。

7.做mixColumn，同樣得先建置一個空的陣列存放mix完的內容，依照維基的方法採用查表的方式進行乘以2和乘以3的計算，
 方法是下面這條，一欄欄的進行操作，所以要用%4和flag控制下三位的位置，避免跑到下一欄去。
 mixArr[i][j] = ((mul2[parseInt(shiftArr[i][j],16)])^(mul3[parseInt(shiftArr[i][(j+1)%4+flag*4],16)])^(shiftArr[i][(j+2)%4+flag*4])^(shiftArr[i][(j+3)%4+flag*4])).toString(16);
 這裡曾嘗試用mul2['0x'+shiftArr[i][j])來辨識16近位，看能不能少呼叫parseInt()函式，但發現這種方式會讓mul2的索引值成為
 字串，造成換算成別的數字，簡單來說，也就是mul2['0x84']和mul2[0x84]的差別，所以仍繼續使用parseInt()

8.做金鑰的產生，可供輸入以及使用預設值，為方便觀察，預設值以'00'~'0f'代表，產生一陣列key[]。

9.做keyExpansion，照著講義設定為10round，也就是把16bytes擴展成10+1個16bytes的round keys。要生成接下來幾輪的key，
需要生成一個temp[4]，第一步是把最後一欄左位移一位，接著把其內容做sbox的置換，這部分跟subByte()很像，
置換完後和rcon[]進行xor，rcon[]事先從維基百科的Rcon[256]取Rcon[10]
建好，在進行xor時，只有的第一位須要算，要先加上0x告訴電腦這是16進位的運算。算出來後，最開始的temp[]
就誕生了，接下來生成第一欄的key，方法是用上一回合的同一欄key值和temp[]
做xor。第二欄key生成時，要先把temp更新為第一欄的key值，在和上一回合的第二欄作xor， 依此類推。接下來的回合也是同樣作法。

10.addRound()，這裡就把key依照回合和每次的state xor就可以了

11.基本功能都完成後，就是密文的生成了，把它們包在encrypt()裡面，並顯示輸出結果。


全部做完以後，發現壞了，是mixcolumn 步驟出了問題，還需要再檢查。